package external

import (
	"fmt"
	"os"
)

const (
	fanIn = 128
)

func Sort(fileName string, blockSize int) {
	sp := newSplitter()
	sp.split(fileName, blockSize)

	var (
		blockNames    = sp.blockNames
		mergedNames  = []string{}
		cycleCount  int
		mergedCount int
	)

	// We start working with initial buffers generated by splitter.
	// Then we iteratively merge `fanIn`-sized chunks of those buffers
	// into a smaller set of larger buffers. We have to do this because
	// if we try to work with all initial buffers at once, we might run
	// out of file descriptors.
	for {
		for len(blockNames) > 0 {
			var (
				blocks []*os.File
				offset int
			)
			if len(blockNames) < fanIn {
				offset = len(blockNames)
			} else {
				offset = fanIn
			}

			for _, blockName := range blockNames[:offset] {
				f, err := os.Open(blockName)
				if err != nil {
					panic(err)
				}

				blocks = append(blocks, f)
			}

			mergedName := fmt.Sprintf("merged_%d_%d", cycleCount, mergedCount)
			w, err := os.Create(mergedName)
			if err != nil {
				panic(err)
			}

			merge(blocks, w)
			mergedNames = append(mergedNames, mergedName)
			mergedCount++
			blockNames = blockNames[offset:]
		}

		// The last iteration will merge remaining buffers into one final
		// sorted file, which we simply rename.
		if len(mergedNames) < 2 {
			outName := fmt.Sprintf("sorted.%s", fileName)
			os.Rename(mergedNames[0], outName)
			return
		}

		blockNames = mergedNames
		mergedNames = []string{}
		cycleCount++
	}
}
